#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           backRight,     tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_6)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//pid attempt

#pragma DebuggerWindows("Globals");
#pragma DebuggerWindows("Motors");

void moveUD(int speed){
	motor[frontLeft] = speed;
	motor[frontRight] = speed;
	motor[backLeft] = -speed;
	motor[backRight] = -speed;
}

void moveRL(int speed){
	motor[frontLeft] = speed;
	motor[frontRight] = -speed;
	motor[backLeft] = speed;
	motor[backRight] = -speed;
}
void moveTurn(int speed){
	motor[frontLeft] = speed;
	motor[frontRight] = speed;
	motor[backLeft] = speed;
	motor[backRight] = speed;
}
int inchToTicks(float inch){
	int ticks;
	ticks = inch *83.184877;
	return ticks;
}

int degreesToTicks(float degree){
	int ticksPerTurn = 3000;//will have to find this for ourselves
	int ticks = degree*ticksPerTurn/360;
	return ticks;
}

int fixTimerValue(float rawSeconds){
	int miliseconds;
	miliseconds = rawSeconds * 100;
	if(miliseconds < 250){
		miliseconds = 250;
	}
	return miliseconds;
}

void PIDBaseControl(float target, float waitTime, int direction, float maxPower = 1){
	float Kp = 0.2;
	float Ki = 0.05;
	float Kd = 0.5;
	int error;
	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;
	float integralActiveZone = inchToTicks(3.0);
	float integralPowerLimit = 50/Ki;
	int finalPower;
	bool timerBool = true;
	nMotorEncoder[frontRight] = 0;
	nMotorEncoder[frontLeft] = 0;
	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backLeft] = 0;
	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime)){
		error = inchToTicks(target) - (nMotorEncoder[frontRight] + nMotorEncoder[frontLeft] + 	nMotorEncoder[backLeft] +  	nMotorEncoder[backLeft]);
		proportion = Kp*error;
		if (abs(error) < integralActiveZone && error != 0){
			integralRaw = integralRaw + error;
			}else{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit){
			integralRaw = integralPowerLimit;
		}
		else if(integralRaw < -integralPowerLimit){
		  integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;
		derivative = Kd * (error - lastError);
		lastError = error;
		if(error == 0){
		 derivative = 0;
		}
		finalPower = proportion + integral + derivative;
		if(finalPower > maxPower * 127){
		  finalPower = maxPower * 127;
		}
		else if (finalPower < -maxPower * 127){
		finalPower = -maxPower * 127;
		}

		if(direction == 1){
			moveUD(finalPower);
		}else
		{
			moveRL(finalPower);
		}
		wait1Msec(40);
		if(error < 30){
			timerBool = false;
		}
		if(timerBool){
			clearTimer(T1);
		}
	}
	moveUD(0);
}

void PIDBaseTurn(int target, float waitTime,float maxPower = 1){
	float Kp = 0.2;
	float Ki = 0.05;
	float Kd = 0.5;
	int error;
	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;
	float integralActiveZone = degreesToTicks(10);
	float integralPowerLimit = 50/Ki;
	int finalPower;
	bool timerBool = true;
	nMotorEncoder[frontRight] = 0;
	nMotorEncoder[frontLeft] = 0;
	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backLeft] = 0;
	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime)){
		error = degreesToTicks(target) - (nMotorEncoder[frontRight] + nMotorEncoder[frontLeft] + 	nMotorEncoder[backLeft] +  	nMotorEncoder[backLeft]);
		proportion = Kp*error;
		if (abs(error) < integralActiveZone && error != 0){
			integralRaw = integralRaw + error;
			}else{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit){
			integralRaw = integralPowerLimit;
		}
		else if(integralRaw < -integralPowerLimit){
		  integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;
		derivative = Kd * (error - lastError);
		lastError = error;
		if(error == 0){
		 derivative = 0;
		}
		finalPower = proportion + integral + derivative;
		if(finalPower > maxPower * 127){
		  finalPower = maxPower * 127;
		}
		else if (finalPower < -maxPower * 127){
		finalPower = -maxPower * 127;
		}

		moveTurn(finalPower);

		wait1Msec(40);
		if(error < 30){
			timerBool = false;
		}
		if(timerBool){
			clearTimer(T1);
		}
	}
	moveTurn(0);
}

task main()
{
	PIDBaseControl(12, 0.5, 1, 0.8);
	PIDBaseTurn(90, 1, 0.75);


}
